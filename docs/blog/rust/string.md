# 字符串
> 在rust中，字符串的使用相对其他语言而言特别复杂，因为它并不是基本类型(**注意这里说的是字符串，不是字符**)。

## 字符串与切片
实际上，像`"hello,world"`这种字面量字符串，是一个切片类型。它可以这里声明类型：
```rust
let s:&str = "hello,world"
```
 之前我们发现，字面量字符串在赋值之后不会转移所有权：
```rust
fn main() {
    // 这里可以看到，x也不过是一个引用而已
    let x: &str = "hello, world";
    let y = x;
    //所以下面不会报错，无论x和y都只是引用，并没有发生所有权转移
    println!("{},{}",x,y);
}
```
那么字面量`"hello，world"`的所有权到底是谁呢？这里需要再看一个例子:
```rust
let s1 = String::from("hello");
let s2 = s1;
// 会报错，因为s1的所有权已经转移，因此赋值到s2之后已经无效
println!("{}, world!", s1);
```

这里就存在一个区别：
- 字面量创建的字符串它本身是个切片，也就是说它本身也是个引用，因此不存在所有权
- 使用`String::from`创建的字符串，是带所有权的，它是运行时实实在在创建出来的值

疑问：为什么绑定了字面量字符串的变量会不带所有权呢？这个值真实的所有权持有者是谁？
> 这里有一个额外的知识点：
> 1. 在内存管理中。Rust除了使用堆栈，还使用全局内存区(静态变量区和字面量区)，Rust编译器会将全局内存区的数据直接嵌入在二进制程序文件中，当启动并加载程序时，嵌入在全局内存区的数据被放入内存的某个位置。
> 2. 全局内存区的数据是编译期间就可确定的，且存活于整个程序运行期间。
> 3. 字符串字面量、static定义的静态变量(相当于全局变量)都会硬编码嵌入到二进制程序的全局内存区。

通过以上我们可以知道。字面量字符串实际上在编译期间已经被硬编码到了一个二进制文件中，运行时加载到全局内存里(可以类比为js中的全局环境变量)，因此我们代码中编写的`let x:&str = "hello, world"`，会变成`"hello, world"`这个全局变量值的一个切片引用。硬是要理解所有权的话，姑且可以想象`"hello, world"`这个值的所有权所有者是全局内存，但是全局内存是不可能销毁的，因此字面量字符串被绑定到某个变量时就只能转化为对全局变量某个部分的切片引用。

## 什么是字符串
字符串就是由一连串字符组合而成的连续集合。

Rust 在语言级别，只有一种字符串类型：` str`，它通常是以引用类型出现 `&str`，也就是上文提到的字符串切片。虽然语言级别只有上述的` str `类型，但是在标准库里，还有多种不同用途的字符串类型，其中使用最广的即是` String `类型。

str 类型(纯字面量创建的字符串而非`String::from`)是硬编码进可执行文件，也无法被修改，但是` String `则是一个可增长、可改变且具有所有权的` UTF-8 `编码字符串，当 Rust 用户提到字符串时，往往指的就是` String` 类型和` &str `字符串切片类型，这两个类型都是` UTF-8 `编码。

### String 和 &str 转换
- `&str` 转 `String`:
```rust
// 本身字面量字符串已经是&str，因此可以使用String::from
let s1 = String::from("yes");
// 或者调用to_string方法
let s2 = "yes".to_string();
```

- `String` 转 `&str`
```rust
// 我们说过字符串实际上是切片引用，因此可以直接对String取引用来获取&str
let s = String::from("yes");
let s1 = &s[..];
```

### 操作字符串
> 在rust中操作字符串是非常容易踩坑的！

和字符不一样，字符是`unicode`类型，每个字符占4个字节的内存空间，但是字符串是以`UTF-8`编码规则来把每个字符转换为`unicode`，因此字符串里的每个字符占用的字节空间会在1～4之间。

这意味着什么？意味着字符串的长度和索引并不是我们想象中那样(如果用js的字符串来类比，直接就GG了)。
#### 字符串的长度
一般而言，我们看到字面量字符串，就会潜移默化认为它的字符个数就是它的长度，但是实际上并不是。rust的字符串底层的数据存储格式实际上是一个 `u8` 组成的数组，前面也提到过，整个字符串使用`UTF-8`编码，所以每个字符它既可能占1个字节也可能占2个字节甚至4个字节：
```rust
let s1 = String::from("中国人");
// [228, 184, 173, 229, 155, 189, 228, 186, 186]
println!("{:?}", s1.as_bytes());

let s2 = String::from("abc");
// [97, 98, 99]
println!("{:?}", s2.as_bytes());
```
可以发现，在`UTF-8` 编码下，大部分汉字占了三个字节，所以`”中国人“`字符串的长度会是9，而`"abc"`纯英文每个只占1个字节，因此整个字符串长度是3。这个就比较反直觉了，要是换做在js中，两者的长度应该都是3。

#### 字符串的索引
由于rust中字符串的长度实际上是取数据存储时的`u8`数组长度，因此这就决定了在rust中用索引来取字符串中的某个字符会非常危险！比如在`"中国人"`这个字符串中，我们想获取`"中"`字，按常规理解那就是直接索引取0，然而事情没有那么简单：
```rust
let s1 = String::from("中国人");
let h = s1[0];

error[E0277]: the type `String` cannot be indexed by `{integer}`
 --> src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index<{integer}>` is not implemented for `String`
```
当我们想着靠索引直接取某个字符时，会直接报错。这是因为，在`UTF-8` 编码下，每个字符会占1~4个字节不等，而字符串存储的数据格式又是个`u8`数组，因此极有可能会出现一种情况是，我们索引取出来的那个字节，无法映射任何一个`unicode`码表里的符号。（比如你要取一个汉字，你可能至少要取三个连续字节）因此在rust中,更推荐的是使用切片的方式获取自己想要的字符串部分:
```rust
let s1 = String::from("中国人");
// 依然是按字节长度来取，中字占3个字节，那就是索引0-2
let h = &s1[..3];
```
